{"ast":null,"code":"/** @license React vundefined\r\n * react-refresh-runtime.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict'; // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n    var REACT_ELEMENT_TYPE = 0xeac7;\n    var REACT_PORTAL_TYPE = 0xeaca;\n    var REACT_FRAGMENT_TYPE = 0xeacb;\n    var REACT_STRICT_MODE_TYPE = 0xeacc;\n    var REACT_PROFILER_TYPE = 0xead2;\n    var REACT_PROVIDER_TYPE = 0xeacd;\n    var REACT_CONTEXT_TYPE = 0xeace;\n    var REACT_FORWARD_REF_TYPE = 0xead0;\n    var REACT_SUSPENSE_TYPE = 0xead1;\n    var REACT_SUSPENSE_LIST_TYPE = 0xead8;\n    var REACT_MEMO_TYPE = 0xead3;\n    var REACT_LAZY_TYPE = 0xead4;\n    var REACT_BLOCK_TYPE = 0xead9;\n    var REACT_SERVER_BLOCK_TYPE = 0xeada;\n    var REACT_FUNDAMENTAL_TYPE = 0xead5;\n    var REACT_RESPONDER_TYPE = 0xead6;\n    var REACT_SCOPE_TYPE = 0xead7;\n    var REACT_OPAQUE_ID_TYPE = 0xeae0;\n    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\n    var REACT_OFFSCREEN_TYPE = 0xeae2;\n    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\n    if (typeof Symbol === 'function' && Symbol.for) {\n      var symbolFor = Symbol.for;\n      REACT_ELEMENT_TYPE = symbolFor('react.element');\n      REACT_PORTAL_TYPE = symbolFor('react.portal');\n      REACT_FRAGMENT_TYPE = symbolFor('react.fragment');\n      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n      REACT_PROFILER_TYPE = symbolFor('react.profiler');\n      REACT_PROVIDER_TYPE = symbolFor('react.provider');\n      REACT_CONTEXT_TYPE = symbolFor('react.context');\n      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n      REACT_MEMO_TYPE = symbolFor('react.memo');\n      REACT_LAZY_TYPE = symbolFor('react.lazy');\n      REACT_BLOCK_TYPE = symbolFor('react.block');\n      REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n      REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n      REACT_RESPONDER_TYPE = symbolFor('react.responder');\n      REACT_SCOPE_TYPE = symbolFor('react.scope');\n      REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n      REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n    }\n\n    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\n    // It's OK to reference families, but use WeakMap/Set for types.\n\n    var allFamiliesByID = new Map();\n    var allFamiliesByType = new PossiblyWeakMap();\n    var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\n    // that have actually been edited here. This keeps checks fast.\n    // $FlowIssue\n\n    var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\n    // It is an array of [Family, NextType] tuples.\n\n    var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\n\n    var helpersByRendererID = new Map();\n    var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\n\n    var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.\n\n    var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.\n    // It needs to be weak because we do this even for roots that failed to mount.\n    // If there is no WeakMap, we won't attempt to do retrying.\n    // $FlowIssue\n\n    var rootElements = // $FlowIssue\n    typeof WeakMap === 'function' ? new WeakMap() : null;\n    var isPerformingRefresh = false;\n\n    function computeFullKey(signature) {\n      if (signature.fullKey !== null) {\n        return signature.fullKey;\n      }\n\n      var fullKey = signature.ownKey;\n      var hooks;\n\n      try {\n        hooks = signature.getCustomHooks();\n      } catch (err) {\n        // This can happen in an edge case, e.g. if expression like Foo.useSomething\n        // depends on Foo which is lazily initialized during rendering.\n        // In that case just assume we'll have to remount.\n        signature.forceReset = true;\n        signature.fullKey = fullKey;\n        return fullKey;\n      }\n\n      for (var i = 0; i < hooks.length; i++) {\n        var hook = hooks[i];\n\n        if (typeof hook !== 'function') {\n          // Something's wrong. Assume we need to remount.\n          signature.forceReset = true;\n          signature.fullKey = fullKey;\n          return fullKey;\n        }\n\n        var nestedHookSignature = allSignaturesByType.get(hook);\n\n        if (nestedHookSignature === undefined) {\n          // No signature means Hook wasn't in the source code, e.g. in a library.\n          // We'll skip it because we can assume it won't change during this session.\n          continue;\n        }\n\n        var nestedHookKey = computeFullKey(nestedHookSignature);\n\n        if (nestedHookSignature.forceReset) {\n          signature.forceReset = true;\n        }\n\n        fullKey += '\\n---\\n' + nestedHookKey;\n      }\n\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n\n    function haveEqualSignatures(prevType, nextType) {\n      var prevSignature = allSignaturesByType.get(prevType);\n      var nextSignature = allSignaturesByType.get(nextType);\n\n      if (prevSignature === undefined && nextSignature === undefined) {\n        return true;\n      }\n\n      if (prevSignature === undefined || nextSignature === undefined) {\n        return false;\n      }\n\n      if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n        return false;\n      }\n\n      if (nextSignature.forceReset) {\n        return false;\n      }\n\n      return true;\n    }\n\n    function isReactClass(type) {\n      return type.prototype && type.prototype.isReactComponent;\n    }\n\n    function canPreserveStateBetween(prevType, nextType) {\n      if (isReactClass(prevType) || isReactClass(nextType)) {\n        return false;\n      }\n\n      if (haveEqualSignatures(prevType, nextType)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function resolveFamily(type) {\n      // Only check updated types to keep lookups fast.\n      return updatedFamiliesByType.get(type);\n    } // If we didn't care about IE11, we could use new Map/Set(iterable).\n\n\n    function cloneMap(map) {\n      var clone = new Map();\n      map.forEach(function (value, key) {\n        clone.set(key, value);\n      });\n      return clone;\n    }\n\n    function cloneSet(set) {\n      var clone = new Set();\n      set.forEach(function (value) {\n        clone.add(value);\n      });\n      return clone;\n    }\n\n    function performReactRefresh() {\n      if (pendingUpdates.length === 0) {\n        return null;\n      }\n\n      if (isPerformingRefresh) {\n        return null;\n      }\n\n      isPerformingRefresh = true;\n\n      try {\n        var staleFamilies = new Set();\n        var updatedFamilies = new Set();\n        var updates = pendingUpdates;\n        pendingUpdates = [];\n        updates.forEach(function (_ref) {\n          var family = _ref[0],\n              nextType = _ref[1]; // Now that we got a real edit, we can create associations\n          // that will be read by the React reconciler.\n\n          var prevType = family.current;\n          updatedFamiliesByType.set(prevType, family);\n          updatedFamiliesByType.set(nextType, family);\n          family.current = nextType; // Determine whether this should be a re-render or a re-mount.\n\n          if (canPreserveStateBetween(prevType, nextType)) {\n            updatedFamilies.add(family);\n          } else {\n            staleFamilies.add(family);\n          }\n        }); // TODO: rename these fields to something more meaningful.\n\n        var update = {\n          updatedFamilies: updatedFamilies,\n          // Families that will re-render preserving state\n          staleFamilies: staleFamilies // Families that will be remounted\n\n        };\n        helpersByRendererID.forEach(function (helpers) {\n          // Even if there are no roots, set the handler on first update.\n          // This ensures that if *new* roots are mounted, they'll use the resolve handler.\n          helpers.setRefreshHandler(resolveFamily);\n        });\n        var didError = false;\n        var firstError = null; // We snapshot maps and sets that are mutated during commits.\n        // If we don't do this, there is a risk they will be mutated while\n        // we iterate over them. For example, trying to recover a failed root\n        // may cause another root to be added to the failed list -- an infinite loop.\n\n        var failedRootsSnapshot = cloneSet(failedRoots);\n        var mountedRootsSnapshot = cloneSet(mountedRoots);\n        var helpersByRootSnapshot = cloneMap(helpersByRoot);\n        failedRootsSnapshot.forEach(function (root) {\n          var helpers = helpersByRootSnapshot.get(root);\n\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n\n          if (!failedRoots.has(root)) {// No longer failed.\n          }\n\n          if (rootElements === null) {\n            return;\n          }\n\n          if (!rootElements.has(root)) {\n            return;\n          }\n\n          var element = rootElements.get(root);\n\n          try {\n            helpers.scheduleRoot(root, element);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            } // Keep trying other roots.\n\n          }\n        });\n        mountedRootsSnapshot.forEach(function (root) {\n          var helpers = helpersByRootSnapshot.get(root);\n\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n\n          if (!mountedRoots.has(root)) {// No longer mounted.\n          }\n\n          try {\n            helpers.scheduleRefresh(root, update);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            } // Keep trying other roots.\n\n          }\n        });\n\n        if (didError) {\n          throw firstError;\n        }\n\n        return update;\n      } finally {\n        isPerformingRefresh = false;\n      }\n    }\n\n    function register(type, id) {\n      {\n        if (type === null) {\n          return;\n        }\n\n        if (typeof type !== 'function' && typeof type !== 'object') {\n          return;\n        } // This can happen in an edge case, e.g. if we register\n        // return value of a HOC but it returns a cached component.\n        // Ignore anything but the first registration for each type.\n\n\n        if (allFamiliesByType.has(type)) {\n          return;\n        } // Create family or remember to update it.\n        // None of this bookkeeping affects reconciliation\n        // until the first performReactRefresh() call above.\n\n\n        var family = allFamiliesByID.get(id);\n\n        if (family === undefined) {\n          family = {\n            current: type\n          };\n          allFamiliesByID.set(id, family);\n        } else {\n          pendingUpdates.push([family, type]);\n        }\n\n        allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\n\n        if (typeof type === 'object' && type !== null) {\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              register(type.render, id + '$render');\n              break;\n\n            case REACT_MEMO_TYPE:\n              register(type.type, id + '$type');\n              break;\n          }\n        }\n      }\n    }\n\n    function setSignature(type, key) {\n      var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\n      {\n        allSignaturesByType.set(type, {\n          forceReset: forceReset,\n          ownKey: key,\n          fullKey: null,\n          getCustomHooks: getCustomHooks || function () {\n            return [];\n          }\n        });\n      }\n    } // This is lazily called during first render for a type.\n    // It captures Hook list at that time so inline requires don't break comparisons.\n\n\n    function collectCustomHooksForSignature(type) {\n      {\n        var signature = allSignaturesByType.get(type);\n\n        if (signature !== undefined) {\n          computeFullKey(signature);\n        }\n      }\n    }\n\n    function getFamilyByID(id) {\n      {\n        return allFamiliesByID.get(id);\n      }\n    }\n\n    function getFamilyByType(type) {\n      {\n        return allFamiliesByType.get(type);\n      }\n    }\n\n    function findAffectedHostInstances(families) {\n      {\n        var affectedInstances = new Set();\n        mountedRoots.forEach(function (root) {\n          var helpers = helpersByRoot.get(root);\n\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n\n          var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n          instancesForRoot.forEach(function (inst) {\n            affectedInstances.add(inst);\n          });\n        });\n        return affectedInstances;\n      }\n    }\n\n    function injectIntoGlobalHook(globalObject) {\n      {\n        // For React Native, the global hook will be set up by require('react-devtools-core').\n        // That code will run before us. So we need to monkeypatch functions on existing hook.\n        // For React Web, the global hook will be set up by the extension.\n        // This will also run before us.\n        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n        if (hook === undefined) {\n          // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\n          // Note that in this case it's important that renderer code runs *after* this method call.\n          // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\n          var nextID = 0;\n          globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n            renderers: new Map(),\n            supportsFiber: true,\n            inject: function (injected) {\n              return nextID++;\n            },\n            onScheduleFiberRoot: function (id, root, children) {},\n            onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},\n            onCommitFiberUnmount: function () {}\n          };\n        } // Here, we just want to get a reference to scheduleRefresh.\n\n\n        var oldInject = hook.inject;\n\n        hook.inject = function (injected) {\n          var id = oldInject.apply(this, arguments);\n\n          if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n            // This version supports React Refresh.\n            helpersByRendererID.set(id, injected);\n          }\n\n          return id;\n        }; // Do the same for any already injected roots.\n        // This is useful if ReactDOM has already been initialized.\n        // https://github.com/facebook/react/issues/17626\n\n\n        hook.renderers.forEach(function (injected, id) {\n          if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n            // This version supports React Refresh.\n            helpersByRendererID.set(id, injected);\n          }\n        }); // We also want to track currently mounted roots.\n\n        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n\n        var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};\n\n        hook.onScheduleFiberRoot = function (id, root, children) {\n          if (!isPerformingRefresh) {\n            // If it was intentionally scheduled, don't attempt to restore.\n            // This includes intentionally scheduled unmounts.\n            failedRoots.delete(root);\n\n            if (rootElements !== null) {\n              rootElements.set(root, children);\n            }\n          }\n\n          return oldOnScheduleFiberRoot.apply(this, arguments);\n        };\n\n        hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\n          var helpers = helpersByRendererID.get(id);\n\n          if (helpers === undefined) {\n            return;\n          }\n\n          helpersByRoot.set(root, helpers);\n          var current = root.current;\n          var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\n          // This logic is copy-pasted from similar logic in the DevTools backend.\n          // If this breaks with some refactoring, you'll want to update DevTools too.\n\n          if (alternate !== null) {\n            var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;\n            var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n\n            if (!wasMounted && isMounted) {\n              // Mount a new root.\n              mountedRoots.add(root);\n              failedRoots.delete(root);\n            } else if (wasMounted && isMounted) ;else if (wasMounted && !isMounted) {\n              // Unmount an existing root.\n              mountedRoots.delete(root);\n\n              if (didError) {\n                // We'll remount it on future edits.\n                failedRoots.add(root);\n              } else {\n                helpersByRoot.delete(root);\n              }\n            } else if (!wasMounted && !isMounted) {\n              if (didError) {\n                // We'll remount it on future edits.\n                failedRoots.add(root);\n              }\n            }\n          } else {\n            // Mount a new root.\n            mountedRoots.add(root);\n          }\n\n          return oldOnCommitFiberRoot.apply(this, arguments);\n        };\n      }\n    }\n\n    function hasUnrecoverableErrors() {\n      // TODO: delete this after removing dependency in RN.\n      return false;\n    } // Exposed for testing.\n\n\n    function _getMountedRootCount() {\n      {\n        return mountedRoots.size;\n      }\n    } // This is a wrapper over more primitive functions for setting signature.\n    // Signatures let us decide whether the Hook order has changed on refresh.\n    //\n    // This function is intended to be used as a transform target, e.g.:\n    // var _s = createSignatureFunctionForTransform()\n    //\n    // function Hello() {\n    //   const [foo, setFoo] = useState(0);\n    //   const value = useCustomHook();\n    //   _s(); /* Second call triggers collecting the custom Hook list.\n    //          * This doesn't happen during the module evaluation because we\n    //          * don't want to change the module order with inline requires.\n    //          * Next calls are noops. */\n    //   return <h1>Hi</h1>;\n    // }\n    //\n    // /* First call specifies the signature: */\n    // _s(\n    //   Hello,\n    //   'useState{[foo, setFoo]}(0)',\n    //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\n    // );\n\n\n    function createSignatureFunctionForTransform() {\n      {\n        // We'll fill in the signature in two steps.\n        // First, we'll know the signature itself. This happens outside the component.\n        // Then, we'll know the references to custom Hooks. This happens inside the component.\n        // After that, the returned function will be a fast path no-op.\n        var status = 'needsSignature';\n        var savedType;\n        var hasCustomHooks;\n        return function (type, key, forceReset, getCustomHooks) {\n          switch (status) {\n            case 'needsSignature':\n              if (type !== undefined) {\n                // If we received an argument, this is the initial registration call.\n                savedType = type;\n                hasCustomHooks = typeof getCustomHooks === 'function';\n                setSignature(type, key, forceReset, getCustomHooks); // The next call we expect is from inside a function, to fill in the custom Hooks.\n\n                status = 'needsCustomHooks';\n              }\n\n              break;\n\n            case 'needsCustomHooks':\n              if (hasCustomHooks) {\n                collectCustomHooksForSignature(savedType);\n              }\n\n              status = 'resolved';\n              break;\n          }\n\n          return type;\n        };\n      }\n    }\n\n    function isLikelyComponentType(type) {\n      {\n        switch (typeof type) {\n          case 'function':\n            {\n              // First, deal with classes.\n              if (type.prototype != null) {\n                if (type.prototype.isReactComponent) {\n                  // React class.\n                  return true;\n                }\n\n                var ownNames = Object.getOwnPropertyNames(type.prototype);\n\n                if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\n                  // This looks like a class.\n                  return false;\n                } // eslint-disable-next-line no-proto\n\n\n                if (type.prototype.__proto__ !== Object.prototype) {\n                  // It has a superclass.\n                  return false;\n                } // Pass through.\n                // This looks like a regular function with empty prototype.\n\n              } // For plain functions and arrows, use name as a heuristic.\n\n\n              var name = type.name || type.displayName;\n              return typeof name === 'string' && /^[A-Z]/.test(name);\n            }\n\n          case 'object':\n            {\n              if (type != null) {\n                switch (type.$$typeof) {\n                  case REACT_FORWARD_REF_TYPE:\n                  case REACT_MEMO_TYPE:\n                    // Definitely React components.\n                    return true;\n\n                  default:\n                    return false;\n                }\n              }\n\n              return false;\n            }\n\n          default:\n            {\n              return false;\n            }\n        }\n      }\n    }\n\n    exports._getMountedRootCount = _getMountedRootCount;\n    exports.collectCustomHooksForSignature = collectCustomHooksForSignature;\n    exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\n    exports.findAffectedHostInstances = findAffectedHostInstances;\n    exports.getFamilyByID = getFamilyByID;\n    exports.getFamilyByType = getFamilyByType;\n    exports.hasUnrecoverableErrors = hasUnrecoverableErrors;\n    exports.injectIntoGlobalHook = injectIntoGlobalHook;\n    exports.isLikelyComponentType = isLikelyComponentType;\n    exports.performReactRefresh = performReactRefresh;\n    exports.register = register;\n    exports.setSignature = setSignature;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","REACT_ELEMENT_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_PROVIDER_TYPE","REACT_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_BLOCK_TYPE","REACT_SERVER_BLOCK_TYPE","REACT_FUNDAMENTAL_TYPE","REACT_RESPONDER_TYPE","REACT_SCOPE_TYPE","REACT_OPAQUE_ID_TYPE","REACT_DEBUG_TRACING_MODE_TYPE","REACT_OFFSCREEN_TYPE","REACT_LEGACY_HIDDEN_TYPE","Symbol","for","symbolFor","PossiblyWeakMap","WeakMap","Map","allFamiliesByID","allFamiliesByType","allSignaturesByType","updatedFamiliesByType","pendingUpdates","helpersByRendererID","helpersByRoot","mountedRoots","Set","failedRoots","rootElements","isPerformingRefresh","computeFullKey","signature","fullKey","ownKey","hooks","getCustomHooks","err","forceReset","i","length","hook","nestedHookSignature","get","undefined","nestedHookKey","haveEqualSignatures","prevType","nextType","prevSignature","nextSignature","isReactClass","type","prototype","isReactComponent","canPreserveStateBetween","resolveFamily","cloneMap","map","clone","forEach","value","key","set","cloneSet","add","performReactRefresh","staleFamilies","updatedFamilies","updates","_ref","family","current","update","helpers","setRefreshHandler","didError","firstError","failedRootsSnapshot","mountedRootsSnapshot","helpersByRootSnapshot","root","Error","has","element","scheduleRoot","scheduleRefresh","register","id","push","$$typeof","render","setSignature","arguments","collectCustomHooksForSignature","getFamilyByID","getFamilyByType","findAffectedHostInstances","families","affectedInstances","instancesForRoot","findHostInstancesForRefresh","inst","injectIntoGlobalHook","globalObject","__REACT_DEVTOOLS_GLOBAL_HOOK__","nextID","renderers","supportsFiber","inject","injected","onScheduleFiberRoot","children","onCommitFiberRoot","maybePriorityLevel","onCommitFiberUnmount","oldInject","apply","oldOnCommitFiberRoot","oldOnScheduleFiberRoot","delete","alternate","wasMounted","memoizedState","isMounted","hasUnrecoverableErrors","_getMountedRootCount","size","createSignatureFunctionForTransform","status","savedType","hasCustomHooks","isLikelyComponentType","ownNames","Object","getOwnPropertyNames","__proto__","name","displayName","test","exports"],"sources":["D:/razzak/React_Django_Ecommerce_Sara-Fashion/frontend/node_modules/react-refresh/cjs/react-refresh-runtime.development.js"],"sourcesContent":["/** @license React vundefined\r\n * react-refresh-runtime.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\n\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n'use strict';\r\n\r\n// ATTENTION\r\n// When adding new symbols to this file,\r\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\r\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\r\n// nor polyfill, then a plain number is used for performance.\r\nvar REACT_ELEMENT_TYPE = 0xeac7;\r\nvar REACT_PORTAL_TYPE = 0xeaca;\r\nvar REACT_FRAGMENT_TYPE = 0xeacb;\r\nvar REACT_STRICT_MODE_TYPE = 0xeacc;\r\nvar REACT_PROFILER_TYPE = 0xead2;\r\nvar REACT_PROVIDER_TYPE = 0xeacd;\r\nvar REACT_CONTEXT_TYPE = 0xeace;\r\nvar REACT_FORWARD_REF_TYPE = 0xead0;\r\nvar REACT_SUSPENSE_TYPE = 0xead1;\r\nvar REACT_SUSPENSE_LIST_TYPE = 0xead8;\r\nvar REACT_MEMO_TYPE = 0xead3;\r\nvar REACT_LAZY_TYPE = 0xead4;\r\nvar REACT_BLOCK_TYPE = 0xead9;\r\nvar REACT_SERVER_BLOCK_TYPE = 0xeada;\r\nvar REACT_FUNDAMENTAL_TYPE = 0xead5;\r\nvar REACT_RESPONDER_TYPE = 0xead6;\r\nvar REACT_SCOPE_TYPE = 0xead7;\r\nvar REACT_OPAQUE_ID_TYPE = 0xeae0;\r\nvar REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\r\nvar REACT_OFFSCREEN_TYPE = 0xeae2;\r\nvar REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\r\n\r\nif (typeof Symbol === 'function' && Symbol.for) {\r\n  var symbolFor = Symbol.for;\r\n  REACT_ELEMENT_TYPE = symbolFor('react.element');\r\n  REACT_PORTAL_TYPE = symbolFor('react.portal');\r\n  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');\r\n  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\r\n  REACT_PROFILER_TYPE = symbolFor('react.profiler');\r\n  REACT_PROVIDER_TYPE = symbolFor('react.provider');\r\n  REACT_CONTEXT_TYPE = symbolFor('react.context');\r\n  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\r\n  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\r\n  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\r\n  REACT_MEMO_TYPE = symbolFor('react.memo');\r\n  REACT_LAZY_TYPE = symbolFor('react.lazy');\r\n  REACT_BLOCK_TYPE = symbolFor('react.block');\r\n  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\r\n  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\r\n  REACT_RESPONDER_TYPE = symbolFor('react.responder');\r\n  REACT_SCOPE_TYPE = symbolFor('react.scope');\r\n  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\r\n  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\r\n  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\r\n  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\r\n}\r\n\r\nvar PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\r\n// It's OK to reference families, but use WeakMap/Set for types.\r\n\r\nvar allFamiliesByID = new Map();\r\nvar allFamiliesByType = new PossiblyWeakMap();\r\nvar allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\r\n// that have actually been edited here. This keeps checks fast.\r\n// $FlowIssue\r\n\r\nvar updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\r\n// It is an array of [Family, NextType] tuples.\r\n\r\nvar pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\r\n\r\nvar helpersByRendererID = new Map();\r\nvar helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\r\n\r\nvar mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.\r\n\r\nvar failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.\r\n// It needs to be weak because we do this even for roots that failed to mount.\r\n// If there is no WeakMap, we won't attempt to do retrying.\r\n// $FlowIssue\r\n\r\nvar rootElements = // $FlowIssue\r\ntypeof WeakMap === 'function' ? new WeakMap() : null;\r\nvar isPerformingRefresh = false;\r\n\r\nfunction computeFullKey(signature) {\r\n  if (signature.fullKey !== null) {\r\n    return signature.fullKey;\r\n  }\r\n\r\n  var fullKey = signature.ownKey;\r\n  var hooks;\r\n\r\n  try {\r\n    hooks = signature.getCustomHooks();\r\n  } catch (err) {\r\n    // This can happen in an edge case, e.g. if expression like Foo.useSomething\r\n    // depends on Foo which is lazily initialized during rendering.\r\n    // In that case just assume we'll have to remount.\r\n    signature.forceReset = true;\r\n    signature.fullKey = fullKey;\r\n    return fullKey;\r\n  }\r\n\r\n  for (var i = 0; i < hooks.length; i++) {\r\n    var hook = hooks[i];\r\n\r\n    if (typeof hook !== 'function') {\r\n      // Something's wrong. Assume we need to remount.\r\n      signature.forceReset = true;\r\n      signature.fullKey = fullKey;\r\n      return fullKey;\r\n    }\r\n\r\n    var nestedHookSignature = allSignaturesByType.get(hook);\r\n\r\n    if (nestedHookSignature === undefined) {\r\n      // No signature means Hook wasn't in the source code, e.g. in a library.\r\n      // We'll skip it because we can assume it won't change during this session.\r\n      continue;\r\n    }\r\n\r\n    var nestedHookKey = computeFullKey(nestedHookSignature);\r\n\r\n    if (nestedHookSignature.forceReset) {\r\n      signature.forceReset = true;\r\n    }\r\n\r\n    fullKey += '\\n---\\n' + nestedHookKey;\r\n  }\r\n\r\n  signature.fullKey = fullKey;\r\n  return fullKey;\r\n}\r\n\r\nfunction haveEqualSignatures(prevType, nextType) {\r\n  var prevSignature = allSignaturesByType.get(prevType);\r\n  var nextSignature = allSignaturesByType.get(nextType);\r\n\r\n  if (prevSignature === undefined && nextSignature === undefined) {\r\n    return true;\r\n  }\r\n\r\n  if (prevSignature === undefined || nextSignature === undefined) {\r\n    return false;\r\n  }\r\n\r\n  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\r\n    return false;\r\n  }\r\n\r\n  if (nextSignature.forceReset) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction isReactClass(type) {\r\n  return type.prototype && type.prototype.isReactComponent;\r\n}\r\n\r\nfunction canPreserveStateBetween(prevType, nextType) {\r\n  if (isReactClass(prevType) || isReactClass(nextType)) {\r\n    return false;\r\n  }\r\n\r\n  if (haveEqualSignatures(prevType, nextType)) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction resolveFamily(type) {\r\n  // Only check updated types to keep lookups fast.\r\n  return updatedFamiliesByType.get(type);\r\n} // If we didn't care about IE11, we could use new Map/Set(iterable).\r\n\r\n\r\nfunction cloneMap(map) {\r\n  var clone = new Map();\r\n  map.forEach(function (value, key) {\r\n    clone.set(key, value);\r\n  });\r\n  return clone;\r\n}\r\n\r\nfunction cloneSet(set) {\r\n  var clone = new Set();\r\n  set.forEach(function (value) {\r\n    clone.add(value);\r\n  });\r\n  return clone;\r\n}\r\n\r\nfunction performReactRefresh() {\r\n\r\n  if (pendingUpdates.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  if (isPerformingRefresh) {\r\n    return null;\r\n  }\r\n\r\n  isPerformingRefresh = true;\r\n\r\n  try {\r\n    var staleFamilies = new Set();\r\n    var updatedFamilies = new Set();\r\n    var updates = pendingUpdates;\r\n    pendingUpdates = [];\r\n    updates.forEach(function (_ref) {\r\n      var family = _ref[0],\r\n          nextType = _ref[1];\r\n      // Now that we got a real edit, we can create associations\r\n      // that will be read by the React reconciler.\r\n      var prevType = family.current;\r\n      updatedFamiliesByType.set(prevType, family);\r\n      updatedFamiliesByType.set(nextType, family);\r\n      family.current = nextType; // Determine whether this should be a re-render or a re-mount.\r\n\r\n      if (canPreserveStateBetween(prevType, nextType)) {\r\n        updatedFamilies.add(family);\r\n      } else {\r\n        staleFamilies.add(family);\r\n      }\r\n    }); // TODO: rename these fields to something more meaningful.\r\n\r\n    var update = {\r\n      updatedFamilies: updatedFamilies,\r\n      // Families that will re-render preserving state\r\n      staleFamilies: staleFamilies // Families that will be remounted\r\n\r\n    };\r\n    helpersByRendererID.forEach(function (helpers) {\r\n      // Even if there are no roots, set the handler on first update.\r\n      // This ensures that if *new* roots are mounted, they'll use the resolve handler.\r\n      helpers.setRefreshHandler(resolveFamily);\r\n    });\r\n    var didError = false;\r\n    var firstError = null; // We snapshot maps and sets that are mutated during commits.\r\n    // If we don't do this, there is a risk they will be mutated while\r\n    // we iterate over them. For example, trying to recover a failed root\r\n    // may cause another root to be added to the failed list -- an infinite loop.\r\n\r\n    var failedRootsSnapshot = cloneSet(failedRoots);\r\n    var mountedRootsSnapshot = cloneSet(mountedRoots);\r\n    var helpersByRootSnapshot = cloneMap(helpersByRoot);\r\n    failedRootsSnapshot.forEach(function (root) {\r\n      var helpers = helpersByRootSnapshot.get(root);\r\n\r\n      if (helpers === undefined) {\r\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\r\n      }\r\n\r\n      if (!failedRoots.has(root)) {// No longer failed.\r\n      }\r\n\r\n      if (rootElements === null) {\r\n        return;\r\n      }\r\n\r\n      if (!rootElements.has(root)) {\r\n        return;\r\n      }\r\n\r\n      var element = rootElements.get(root);\r\n\r\n      try {\r\n        helpers.scheduleRoot(root, element);\r\n      } catch (err) {\r\n        if (!didError) {\r\n          didError = true;\r\n          firstError = err;\r\n        } // Keep trying other roots.\r\n\r\n      }\r\n    });\r\n    mountedRootsSnapshot.forEach(function (root) {\r\n      var helpers = helpersByRootSnapshot.get(root);\r\n\r\n      if (helpers === undefined) {\r\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\r\n      }\r\n\r\n      if (!mountedRoots.has(root)) {// No longer mounted.\r\n      }\r\n\r\n      try {\r\n        helpers.scheduleRefresh(root, update);\r\n      } catch (err) {\r\n        if (!didError) {\r\n          didError = true;\r\n          firstError = err;\r\n        } // Keep trying other roots.\r\n\r\n      }\r\n    });\r\n\r\n    if (didError) {\r\n      throw firstError;\r\n    }\r\n\r\n    return update;\r\n  } finally {\r\n    isPerformingRefresh = false;\r\n  }\r\n}\r\nfunction register(type, id) {\r\n  {\r\n    if (type === null) {\r\n      return;\r\n    }\r\n\r\n    if (typeof type !== 'function' && typeof type !== 'object') {\r\n      return;\r\n    } // This can happen in an edge case, e.g. if we register\r\n    // return value of a HOC but it returns a cached component.\r\n    // Ignore anything but the first registration for each type.\r\n\r\n\r\n    if (allFamiliesByType.has(type)) {\r\n      return;\r\n    } // Create family or remember to update it.\r\n    // None of this bookkeeping affects reconciliation\r\n    // until the first performReactRefresh() call above.\r\n\r\n\r\n    var family = allFamiliesByID.get(id);\r\n\r\n    if (family === undefined) {\r\n      family = {\r\n        current: type\r\n      };\r\n      allFamiliesByID.set(id, family);\r\n    } else {\r\n      pendingUpdates.push([family, type]);\r\n    }\r\n\r\n    allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\r\n\r\n    if (typeof type === 'object' && type !== null) {\r\n      switch (type.$$typeof) {\r\n        case REACT_FORWARD_REF_TYPE:\r\n          register(type.render, id + '$render');\r\n          break;\r\n\r\n        case REACT_MEMO_TYPE:\r\n          register(type.type, id + '$type');\r\n          break;\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction setSignature(type, key) {\r\n  var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n  var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\r\n\r\n  {\r\n    allSignaturesByType.set(type, {\r\n      forceReset: forceReset,\r\n      ownKey: key,\r\n      fullKey: null,\r\n      getCustomHooks: getCustomHooks || function () {\r\n        return [];\r\n      }\r\n    });\r\n  }\r\n} // This is lazily called during first render for a type.\r\n// It captures Hook list at that time so inline requires don't break comparisons.\r\n\r\nfunction collectCustomHooksForSignature(type) {\r\n  {\r\n    var signature = allSignaturesByType.get(type);\r\n\r\n    if (signature !== undefined) {\r\n      computeFullKey(signature);\r\n    }\r\n  }\r\n}\r\nfunction getFamilyByID(id) {\r\n  {\r\n    return allFamiliesByID.get(id);\r\n  }\r\n}\r\nfunction getFamilyByType(type) {\r\n  {\r\n    return allFamiliesByType.get(type);\r\n  }\r\n}\r\nfunction findAffectedHostInstances(families) {\r\n  {\r\n    var affectedInstances = new Set();\r\n    mountedRoots.forEach(function (root) {\r\n      var helpers = helpersByRoot.get(root);\r\n\r\n      if (helpers === undefined) {\r\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\r\n      }\r\n\r\n      var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\r\n      instancesForRoot.forEach(function (inst) {\r\n        affectedInstances.add(inst);\r\n      });\r\n    });\r\n    return affectedInstances;\r\n  }\r\n}\r\nfunction injectIntoGlobalHook(globalObject) {\r\n  {\r\n    // For React Native, the global hook will be set up by require('react-devtools-core').\r\n    // That code will run before us. So we need to monkeypatch functions on existing hook.\r\n    // For React Web, the global hook will be set up by the extension.\r\n    // This will also run before us.\r\n    var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\r\n\r\n    if (hook === undefined) {\r\n      // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\r\n      // Note that in this case it's important that renderer code runs *after* this method call.\r\n      // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\r\n      var nextID = 0;\r\n      globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\r\n        renderers: new Map(),\r\n        supportsFiber: true,\r\n        inject: function (injected) {\r\n          return nextID++;\r\n        },\r\n        onScheduleFiberRoot: function (id, root, children) {},\r\n        onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},\r\n        onCommitFiberUnmount: function () {}\r\n      };\r\n    } // Here, we just want to get a reference to scheduleRefresh.\r\n\r\n\r\n    var oldInject = hook.inject;\r\n\r\n    hook.inject = function (injected) {\r\n      var id = oldInject.apply(this, arguments);\r\n\r\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\r\n        // This version supports React Refresh.\r\n        helpersByRendererID.set(id, injected);\r\n      }\r\n\r\n      return id;\r\n    }; // Do the same for any already injected roots.\r\n    // This is useful if ReactDOM has already been initialized.\r\n    // https://github.com/facebook/react/issues/17626\r\n\r\n\r\n    hook.renderers.forEach(function (injected, id) {\r\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\r\n        // This version supports React Refresh.\r\n        helpersByRendererID.set(id, injected);\r\n      }\r\n    }); // We also want to track currently mounted roots.\r\n\r\n    var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\r\n\r\n    var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};\r\n\r\n    hook.onScheduleFiberRoot = function (id, root, children) {\r\n      if (!isPerformingRefresh) {\r\n        // If it was intentionally scheduled, don't attempt to restore.\r\n        // This includes intentionally scheduled unmounts.\r\n        failedRoots.delete(root);\r\n\r\n        if (rootElements !== null) {\r\n          rootElements.set(root, children);\r\n        }\r\n      }\r\n\r\n      return oldOnScheduleFiberRoot.apply(this, arguments);\r\n    };\r\n\r\n    hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\r\n      var helpers = helpersByRendererID.get(id);\r\n\r\n      if (helpers === undefined) {\r\n        return;\r\n      }\r\n\r\n      helpersByRoot.set(root, helpers);\r\n      var current = root.current;\r\n      var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\r\n      // This logic is copy-pasted from similar logic in the DevTools backend.\r\n      // If this breaks with some refactoring, you'll want to update DevTools too.\r\n\r\n      if (alternate !== null) {\r\n        var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;\r\n        var isMounted = current.memoizedState != null && current.memoizedState.element != null;\r\n\r\n        if (!wasMounted && isMounted) {\r\n          // Mount a new root.\r\n          mountedRoots.add(root);\r\n          failedRoots.delete(root);\r\n        } else if (wasMounted && isMounted) ; else if (wasMounted && !isMounted) {\r\n          // Unmount an existing root.\r\n          mountedRoots.delete(root);\r\n\r\n          if (didError) {\r\n            // We'll remount it on future edits.\r\n            failedRoots.add(root);\r\n          } else {\r\n            helpersByRoot.delete(root);\r\n          }\r\n        } else if (!wasMounted && !isMounted) {\r\n          if (didError) {\r\n            // We'll remount it on future edits.\r\n            failedRoots.add(root);\r\n          }\r\n        }\r\n      } else {\r\n        // Mount a new root.\r\n        mountedRoots.add(root);\r\n      }\r\n\r\n      return oldOnCommitFiberRoot.apply(this, arguments);\r\n    };\r\n  }\r\n}\r\nfunction hasUnrecoverableErrors() {\r\n  // TODO: delete this after removing dependency in RN.\r\n  return false;\r\n} // Exposed for testing.\r\n\r\nfunction _getMountedRootCount() {\r\n  {\r\n    return mountedRoots.size;\r\n  }\r\n} // This is a wrapper over more primitive functions for setting signature.\r\n// Signatures let us decide whether the Hook order has changed on refresh.\r\n//\r\n// This function is intended to be used as a transform target, e.g.:\r\n// var _s = createSignatureFunctionForTransform()\r\n//\r\n// function Hello() {\r\n//   const [foo, setFoo] = useState(0);\r\n//   const value = useCustomHook();\r\n//   _s(); /* Second call triggers collecting the custom Hook list.\r\n//          * This doesn't happen during the module evaluation because we\r\n//          * don't want to change the module order with inline requires.\r\n//          * Next calls are noops. */\r\n//   return <h1>Hi</h1>;\r\n// }\r\n//\r\n// /* First call specifies the signature: */\r\n// _s(\r\n//   Hello,\r\n//   'useState{[foo, setFoo]}(0)',\r\n//   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\r\n// );\r\n\r\nfunction createSignatureFunctionForTransform() {\r\n  {\r\n    // We'll fill in the signature in two steps.\r\n    // First, we'll know the signature itself. This happens outside the component.\r\n    // Then, we'll know the references to custom Hooks. This happens inside the component.\r\n    // After that, the returned function will be a fast path no-op.\r\n    var status = 'needsSignature';\r\n    var savedType;\r\n    var hasCustomHooks;\r\n    return function (type, key, forceReset, getCustomHooks) {\r\n      switch (status) {\r\n        case 'needsSignature':\r\n          if (type !== undefined) {\r\n            // If we received an argument, this is the initial registration call.\r\n            savedType = type;\r\n            hasCustomHooks = typeof getCustomHooks === 'function';\r\n            setSignature(type, key, forceReset, getCustomHooks); // The next call we expect is from inside a function, to fill in the custom Hooks.\r\n\r\n            status = 'needsCustomHooks';\r\n          }\r\n\r\n          break;\r\n\r\n        case 'needsCustomHooks':\r\n          if (hasCustomHooks) {\r\n            collectCustomHooksForSignature(savedType);\r\n          }\r\n\r\n          status = 'resolved';\r\n          break;\r\n      }\r\n\r\n      return type;\r\n    };\r\n  }\r\n}\r\nfunction isLikelyComponentType(type) {\r\n  {\r\n    switch (typeof type) {\r\n      case 'function':\r\n        {\r\n          // First, deal with classes.\r\n          if (type.prototype != null) {\r\n            if (type.prototype.isReactComponent) {\r\n              // React class.\r\n              return true;\r\n            }\r\n\r\n            var ownNames = Object.getOwnPropertyNames(type.prototype);\r\n\r\n            if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\r\n              // This looks like a class.\r\n              return false;\r\n            } // eslint-disable-next-line no-proto\r\n\r\n\r\n            if (type.prototype.__proto__ !== Object.prototype) {\r\n              // It has a superclass.\r\n              return false;\r\n            } // Pass through.\r\n            // This looks like a regular function with empty prototype.\r\n\r\n          } // For plain functions and arrows, use name as a heuristic.\r\n\r\n\r\n          var name = type.name || type.displayName;\r\n          return typeof name === 'string' && /^[A-Z]/.test(name);\r\n        }\r\n\r\n      case 'object':\r\n        {\r\n          if (type != null) {\r\n            switch (type.$$typeof) {\r\n              case REACT_FORWARD_REF_TYPE:\r\n              case REACT_MEMO_TYPE:\r\n                // Definitely React components.\r\n                return true;\r\n\r\n              default:\r\n                return false;\r\n            }\r\n          }\r\n\r\n          return false;\r\n        }\r\n\r\n      default:\r\n        {\r\n          return false;\r\n        }\r\n    }\r\n  }\r\n}\r\n\r\nexports._getMountedRootCount = _getMountedRootCount;\r\nexports.collectCustomHooksForSignature = collectCustomHooksForSignature;\r\nexports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\r\nexports.findAffectedHostInstances = findAffectedHostInstances;\r\nexports.getFamilyByID = getFamilyByID;\r\nexports.getFamilyByType = getFamilyByType;\r\nexports.hasUnrecoverableErrors = hasUnrecoverableErrors;\r\nexports.injectIntoGlobalHook = injectIntoGlobalHook;\r\nexports.isLikelyComponentType = isLikelyComponentType;\r\nexports.performReactRefresh = performReactRefresh;\r\nexports.register = register;\r\nexports.setSignature = setSignature;\r\n  })();\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}